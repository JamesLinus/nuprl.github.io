<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>PRL Blog: PRL Blog</title>
  <description>PRL Blog: PRL Blog</description>
  <link>http://prl.ccs.neu.edu/blog/index.html</link>
  <lastBuildDate>Mon, 05 Jun 2017 15:47:59 UT</lastBuildDate>
  <pubDate>Mon, 05 Jun 2017 15:47:59 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Report: PLISS 2017</title>
   <link>http://prl.ccs.neu.edu/blog/2017/06/05/report-pliss-2017?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-06-05-report-pliss-2017</guid>
   <pubDate>Mon, 05 Jun 2017 15:47:59 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Two weeks ago, I attended the first &lt;a href="https://pliss2017.github.io/"&gt;Programming Language Implementation Summer School&lt;/a&gt;, held in beautiful Bertinoro, Italy.&lt;/p&gt;

&lt;p&gt;The goal of PLISS was &amp;ldquo;to prepare early graduate students and advanced undergraduates for research in the field,&amp;rdquo; and I think it successfully accomplished that. There were many talks in a variety of areas, such as just-in-time compilers, garbage collection, static analysis, and distributed systems. But PLISS was more than just a series of talks: PLISS provided an environment for interacting with other students as well as senior researchers.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="the-talks"&gt;The Talks&lt;/h2&gt;

&lt;p&gt;With the amount of technical content at PLISS, there was easily something for everyone. &lt;a href="http://janvitek.org/"&gt;Jan Vitek&lt;/a&gt; and &lt;a href="http://tratt.net/laurie/"&gt;Laurence Tratt&lt;/a&gt; gave lectures that included hands-on exercises where we worked on JITs. &lt;a href="https://www.cs.purdue.edu/homes/suresh/"&gt;Suresh Jagannathan&lt;/a&gt; dived into the operational semantics of a distributed system, so we could reason about different weak consistency models. Francesco Logozzo gave us a whirlwind tour of abstract interpretation.&lt;/p&gt;

&lt;p&gt;Most of my favorite talks included some form of extra content, such as exercises, live-coding presentations, or demos. I found it really helpful to write actual code and apply what I had just learned, or to look at some concrete examples. The examples and exercises also helped with the pacing, as actively listening to four 90-minute talks every day is exhausting!&lt;/p&gt;

&lt;p&gt;Off the top of my head, these were some of my favorite talks:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Dynamic Programming Language Implementation with LLVM&lt;/strong&gt;, by Petr Maj, Oli  Fl√ºckiger, and &lt;a href="http://janvitek.org/"&gt;Jan Vitek&lt;/a&gt;. As the first talk of the summer school, this  was a gentle introduction for the rest of the week. We had &lt;a href="https://github.com/PRL-PRG/pliss-rift/"&gt;exercises&lt;/a&gt;  (with intentional bugs to make us think!), and also brief overviews of  intermediate languages, static analysis, and garbage collection. These three  topics would later show up in more detail.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Micro Virtual Machines&lt;/strong&gt;, by &lt;a href="http://users.cecs.anu.edu.au/~steveb/"&gt;Steve Blackburn&lt;/a&gt;. This talk covered  background information on virtual machines, and also the &lt;a href="http://microvm.github.io/"&gt;Micro VM&lt;/a&gt;  project that Steve&amp;rsquo;s group has been working on. A lot of the material was  already familiar to me, but I still enjoyed the talk, and even got a few  ideas for the project I&amp;rsquo;m working on!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Static Analysis&lt;/strong&gt;, by &lt;a href="http://matt.might.net/"&gt;Matt Might&lt;/a&gt;. Matt&amp;rsquo;s talk was based on one of  his &lt;a href="http://matt.might.net/articles/intro-static-analysis/"&gt;articles&lt;/a&gt; and an older talk he&amp;rsquo;s given. Impressively, the entire  example was live-coded, with only a single mistake!&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Testing Language Implementations&lt;/strong&gt;, by &lt;a href="http://multicore.doc.ic.ac.uk/"&gt;Alastair Donaldson&lt;/a&gt;. This was  an entertaining talk, since Ally showed multiple examples of crashing  compilers, and causing other kinds of mischief by triggering compiler bugs.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re disappointed that you couldn&amp;rsquo;t see these talks, don&amp;rsquo;t worry! The talks were recorded and will be posted very shortly.&lt;/p&gt;

&lt;h2 id="the-people"&gt;The People&lt;/h2&gt;

&lt;p&gt;But there&amp;rsquo;s more to PLISS than the talks. I&amp;rsquo;m referring to &lt;em&gt;networking&lt;/em&gt;, or the opportunity to get out and talk to other people about research.&lt;/p&gt;

&lt;p&gt;As an early graduate student, I&amp;rsquo;ve been given a lot of advice about talking to people at conferences and the importance of the &amp;ldquo;hallway track.&amp;rdquo; I still have difficulty doing this at an actual conference, like &lt;a href="http://pldi17.sigplan.org/home"&gt;PLDI&lt;/a&gt; or &lt;a href="http://2017.ecoop.org/"&gt;ECOOP&lt;/a&gt;. When there are hundreds of attendees, or when people already know each other and are in conversation groups, I find it difficult to approach them.&lt;/p&gt;

&lt;p&gt;This was not the case at PLISS. There were fewer attendees: about fifty students and a dozen speakers. There was a good mix of undergraduate, master&amp;rsquo;s, first-year PhD, and more senior PhD students. All our breakfasts, lunches, and breaks were together, so we would see the same people again and again, and inevitably start to learn each other&amp;rsquo;s names. The speakers would also be among us, and there was a good ratio of speakers to students for discussions and mealtime mentoring.&lt;/p&gt;

&lt;p&gt;I had many opportunities to practice my &amp;ldquo;research pitch.&amp;rdquo; I talked to senior students and got advice. I talked to junior students and gave advice. Two different people I talked to about my research pointed me to the same paper to read. I found another student who was working with &lt;a href="http://research.cs.wisc.edu/wpis/papers/popl95.pdf"&gt;IFDS&lt;/a&gt;, an algorithm I have spent much time trying to understand. And, one day at lunch, my table discovered that we were all working on static analysis!&lt;/p&gt;

&lt;p&gt;As much as I enjoyed the talks, I think the best part of PLISS was meeting and talking to other people. You can replace talks with videos (but you lose the speaker-audience interaction), and you can replace conversations with other forms of communication. But there isn&amp;rsquo;t really anything that can replace the serendipity of bumping into someone with a shared interest.&lt;/p&gt;

&lt;h2 id="the-location"&gt;The Location&lt;/h2&gt;

&lt;p&gt;Actually, the &lt;em&gt;other&lt;/em&gt; best part of PLISS was the location. Italy is a beautiful country with delicious food. And Bertinoro is a small town on the top of a hill, with a breathtaking view of the surrounding area. The lectures were held in a &lt;a href="https://pliss2017.github.io/images/pics/7.jpg"&gt;castle at the top of the hill&lt;/a&gt; (photo credit: Steve Blackburn). The speakers lived in the castle for the week, while the students lived in the former monastery (seems fitting), which has been renovated into a university residence.&lt;/p&gt;

&lt;p&gt;Here are my two favorite pictures I took (click for full size):&lt;/p&gt;

&lt;p&gt;&lt;a href="/img/pliss2017-1.jpg"&gt;&lt;img src="/img/pliss2017-1-thumb.jpg" alt="View from the castle" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href="/img/pliss2017-2.jpg"&gt;&lt;img src="/img/pliss2017-2-thumb.jpg" alt="Panorama" /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Steve Blackburn has more pictures posted on the &lt;a href="https://pliss2017.github.io/"&gt;PLISS website&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="final-thoughts"&gt;Final Thoughts&lt;/h2&gt;

&lt;p&gt;PLISS was a wonderful event. Many thanks need to be given to the speakers, organizers, and sponsors, for making this possible!&lt;/p&gt;

&lt;p&gt;If and when there is a second PLISS, I highly encourage students to apply! You will learn a lot from the lectures, from talking to the speakers, and meeting other students. And if it&amp;rsquo;s in Bertinoro again, you can enjoy the weather and nice view!&lt;/p&gt;</description></item>
  <item>
   <title>Racket 6.9 and Windows 10 Creators Update</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/26/racket-6-9-and-windows-10-creators-update?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-26-racket-6-9-and-windows-10-creators-update</guid>
   <pubDate>Fri, 26 May 2017 17:00:28 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;&lt;a href="http://racket-lang.org/"&gt;Racket&lt;/a&gt; 6.9 was released in April and it has been smooth sailing for many people. However, some people using the &lt;a href="https://blogs.windows.com/windowsexperience/2017/04/11/whats-new-in-the-windows-10-creators-update/"&gt;Windows 10 Creators Update&lt;/a&gt; have been experiencing &lt;a href="https://github.com/racket/racket/issues/1671"&gt;crashes&lt;/a&gt;, not just for Racket, but for the whole operating system. This is due to a bug in Windows. We have contacted Microsoft; they have classified the bug as (1) a stack overflow and (2) not a security hazard, and intend to add a fix in a future version of Windows.&lt;/p&gt;

&lt;p&gt;The next version of Racket will include a patch to help avoid triggering the bug. Until then, one work-around is to run Racket in a virtual machine (VM). This blog post is a step-by-step guide on how to install a VM for Racket.&lt;/p&gt;

&lt;p&gt;A VirtualBox image with Racket preinstalled can be downloaded here:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/website/releases/download/racket69vm/Racket_6_9.ova"&gt;https://github.com/nuprl/website/releases/download/racket69vm/Racket_6_9.ova&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The username and password for this machine are both &lt;code&gt;racket&lt;/code&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;The first thing you need to install is virtualization software. In principle it doesn&amp;rsquo;t matter what you install, but for this tutorial, we will use &lt;a href="https://www.virtualbox.org/"&gt;VirtualBox&lt;/a&gt;. Go to their &lt;a href="https://www.virtualbox.org/wiki/Downloads"&gt;downloads&lt;/a&gt; page and download and install the version for your platform (most likely Windows).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Once installed, you need to download a virtual image and install Racket on it. We have prepared an image that comes with Racket pre-installed, which &lt;a href="https://github.com/nuprl/website/releases/download/racket69vm/Racket_6_9.ova"&gt;you can download here&lt;/a&gt;. The rest of this tutorial will assume you are using this image.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Start up VirtualBox and import the virtual machine. You can do this by clicking on &lt;code&gt;File -&amp;gt; Import Appliance&lt;/code&gt;. In the dialog, select the image you downloaded and hit &lt;code&gt;Continue&lt;/code&gt;. The next window lets you change the specs for your virtual machine. Feel free to make any changes you want, but the defaults work fine for this image. Once you are satisfied click &lt;code&gt;Import&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;After import finishes, you should now see your new VM in the list on the left of the VirtualBox manager. Select it and hit &lt;code&gt;Start&lt;/code&gt;. Once started up, you will see DrRacket and Firefox on the VM&amp;rsquo;s desktop.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;</description></item>
  <item>
   <title>Programming Language Conference in Russia</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/24/programming-language-conference-in-russia?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-24-programming-language-conference-in-russia</guid>
   <pubDate>Wed, 24 May 2017 12:25:17 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;In April 3&amp;mdash;5 I took part into a Russian conference exclusively devoted to programming languages: &lt;a href="http://plc.sfedu.ru/"&gt;Programming Languages and Compilers&lt;/a&gt; (&lt;a href="https://translate.google.com/translate?sl=auto&amp;amp;tl=en&amp;amp;js=y&amp;amp;prev=_t&amp;amp;hl=en&amp;amp;ie=UTF-8&amp;amp;u=http%3A%2F%2Fplc.sfedu.ru%2F&amp;amp;edit-text=&amp;amp;act=url"&gt;Google.Translated version of the site&lt;/a&gt;). I was a member of organizing committee and had a paper there.&lt;/p&gt;

&lt;p&gt;This is the first conference in Russia highly focused on our area of PL. At least for the last several decades (I believe, there were conferences of the kind back in USSR). The conference was devoted to the memory of prominent Soviet PL-researcher from Rostov-on-Don, Adolf Fuksman who worked on ideas quite similar to what we know as the aspect-oriented programming back in the 70-s.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;We designed and implemented the conference with my colleagues from I.I.Vorovich institute of Mathematics, Mechanics and Computer Science, Southern Federal University (&lt;a href="https://www.google.com/maps/place/Rostov-on-Don,+Rostov+Oblast,+Russia/@49.8345629,18.9321123,4.5z/data=!4m5!3m4!1s0x40e3c777c3b4b6ef:0x8248b451e48b4d04!8m2!3d47.2357137!4d39.701505"&gt;Rostov-on-Don&lt;/a&gt;, Russia). We aimed at gathering as much PL-researchers and enthusiasts from academia in Russia as we could. One of the consequences of the aim was a decision to run the conference in Russian. Though we missed expertise from our non-Russian speaking colleagues, we got thorough participation from all over Russia:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Saint-Petersburg, Moscow, Novosibirsk, Krasnoyarsk, Ekaterinburg, Kazan, etc.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;I only mention here the cities with more than 1 mil. population in decreasing in number of conference participants order (and excluding Rostov itself, of course).&lt;/p&gt;

&lt;p&gt;I particularly liked talks by invited speakers. When searching for ones, we targeted Russians who work at prominent universities and/or have some visibility at the international level. We ended up with two researchers: &lt;a href="http://ilyasergey.net/"&gt;Ilya Sergey&lt;/a&gt; (University College of London) and &lt;a href="http://www.macs.hw.ac.uk/~ek19/"&gt;Ekaterina Komendantskaya&lt;/a&gt; (Heriot-Watt U., Edinburg, UK). Interestingly, their talks were quite close to each other:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;I. Sergey, Dependent Types for verification of real-world programs,&lt;/li&gt;
 &lt;li&gt;E. Komendantskaya, Automated Theorem Proving for Type Inference, Constructively.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Both of them talked about types as a logic tool to ensure program correctness.&lt;/p&gt;

&lt;p&gt;Biggest opening in this conference for me was a team from Languages Tools Laboratory of &lt;a href="https://en.wikipedia.org/wiki/JetBrains"&gt;JetBrains&lt;/a&gt;. Surely, you heard about JB: either about their famous IDE, IntelliJ IDEA, or the Kotlin programming language (which, by the way, &lt;a href="https://blog.jetbrains.com/kotlin/2017/05/kotlin-on-android-now-official/"&gt;is endorsed&lt;/a&gt; for Android development these days). You may also have noticed that JB become sponsors of ECOOP and OPLSS this year. So we had a whole team of researchers from Saint-Petersburg office of JB. Among their topics: &lt;code&gt;OCaml&lt;/code&gt; embedding of &lt;code&gt;miniKanren&lt;/code&gt; (some results was presented on ML Workshop 2016), parser combinator libraries for &lt;code&gt;OCaml&lt;/code&gt; and constrained graph querying (this is not specifically a PL problem, see &lt;a href="https://arxiv.org/abs/1502.02242"&gt;arXiv:1502.02242&lt;/a&gt; for details).&lt;/p&gt;

&lt;p&gt;Otherwise the spectrum of topics presented on the conference was quite broad, here are some:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Static analysis with PVS-studio (a sponsor talk),&lt;/li&gt;
 &lt;li&gt;supercompilation (a talk by researchers from Pereslavl-Zalesskiy, where the topic is actively developed for decades),&lt;/li&gt;
 &lt;li&gt;C++ and beyond (by a member of the ISO C++ committee),&lt;/li&gt;
 &lt;li&gt;architecture-agnostic parallel programming languages and compilation techniques for parallel architectures,&lt;/li&gt;
 &lt;li&gt;game semantics and ontologies for PL semantics,&lt;/li&gt;
 &lt;li&gt;program analysis,&lt;/li&gt;
 &lt;li&gt;compiler architectures.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Full program with links to slides in Russian is available &lt;a href="https://docs.google.com/spreadsheets/d/11QiFUqJG_NiBHVUfji_6-FiqP3aQWmdDBN13abM32nY/edit?usp=sharing"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let me mention my submission: that was a joint work with a student of mine on exploring design space for parser combinator libraries using programming language with direct support of effect system, namely &lt;a href="http://popl17.sigplan.org/event/popl-2017-papers-do-be-do-be-do"&gt;Frank&lt;/a&gt;. &lt;a href="http://staff.mmcs.sfedu.ru/%7Ejuliet/index.en.html"&gt;Julia Belyakova&lt;/a&gt; also participated in the conference with her work on Coq-certified interpreter for an extension of lambda-calculus with concept-parameters (module-like kind of thing). The follow-up of that work is accepted for FTfJP workshop this year. You can also listen to her on the topic at the &lt;a href="http://www.nepls.org/Events/30/"&gt;NEPLS&lt;/a&gt; next week.&lt;/p&gt;

&lt;p&gt;I hope that we will find sources, time, and, most important, high quality submissions for PLC&amp;ndash;2018.&lt;/p&gt;</description></item>
  <item>
   <title>Building a Website with Scribble</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/23/building-a-website-with-scribble?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-23-building-a-website-with-scribble</guid>
   <pubDate>Tue, 23 May 2017 01:53:13 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The source code for the PRL website is written using Scribble, the Racket  documentation tool. I am very happy with this choice, and you should be too!&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="the-story-so-far"&gt;The Story so Far&lt;/h2&gt;

&lt;p&gt;Last Fall, I took a flight to Chicago (on my way to &lt;a href="http://con.racket-lang.org/2016/"&gt;RacketCon 2016&lt;/a&gt;). When I landed, there was a new message in my inbox:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Subject: Web Page
    Date: 2016-09-15

    You have been nominated webmaster by public acclamation. Congratulations!&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Emboldened by the trust of my people, I promptly converted the PRL website  from Racket-generating-HTML to the fine &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt;  preprocessor language (commit &lt;a href="https://github.com/nuprl/website/commit/a0600d32fec4bd70c5530b2717aec32979d634f7"&gt;&lt;code&gt;a0600d&lt;/code&gt;&lt;/a&gt;) This bold action polarized the community.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;I can&amp;rsquo;t read the source anymore! Is this really an improvement?&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;Fear not, citizens. The switch to &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt; was the right choice, and you  too can learn to read the source code.&lt;/p&gt;

&lt;h2 id="how-to-read-scribblehtml-programs"&gt;How to Read &lt;code&gt;scribble/html&lt;/code&gt; Programs&lt;/h2&gt;

&lt;h3 id="basics"&gt;Basics&lt;/h3&gt;

&lt;p&gt;Scribble is a language for writing Racket documentation. The key innovation in Scribble is the &lt;em&gt;@-expression&lt;/em&gt; (read: &amp;ldquo;at expression&amp;rdquo;). The &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt; language combines @-expression syntax with  functions that generate HTML.&lt;/p&gt;

&lt;h4 id="-syntax"&gt;@-syntax&lt;/h4&gt;

&lt;p&gt;&lt;a href="http://www.greghendershott.com/2015/08/at-expressions.html"&gt;Greg Hendershott&lt;/a&gt; and the &lt;a href="http://docs.racket-lang.org/scribble/reader.html"&gt;Scribble Documentation&lt;/a&gt; explain @-expressions properly. Here&amp;rsquo;s a short tutorial (Part 1 of 2, &amp;ldquo;the basics&amp;rdquo;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Scribble programs start in &amp;ldquo;text mode&amp;rdquo;.  Every character you type goes straight to the document you are building.&lt;/li&gt;
 &lt;li&gt;The @-sign toggles to &amp;ldquo;Racket mode&amp;rdquo; for the next expression.  In Racket mode, the characters you type will be evaluated as a Racket program  to produce part of the document.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Examples:&lt;/em&gt; Evaluating &lt;code&gt;"Hello Dave"&lt;/code&gt; puts &amp;ldquo;Hello Dave&amp;rdquo; in your document. Evaluating &lt;code&gt;"Hello @Dave"&lt;/code&gt; puts &amp;ldquo;Hello ???&amp;rdquo; in your document, where "???" is the value of the variable &lt;code&gt;Dave&lt;/code&gt;. Finally if &lt;code&gt;Dave&lt;/code&gt; is the name of a function, then &lt;code&gt;"Hello @(Dave)"&lt;/code&gt; calls the &lt;code&gt;Dave&lt;/code&gt; function with zero arguments and puts whatever it returns into your document.&lt;/p&gt;

&lt;p&gt;To make it easy to interleave text, function calls, and code, Scribble  discriminates between 4 kinds of parentheses when they follow an @-sign (Part 2 of 2, &amp;ldquo;the parens&amp;rdquo;):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;@(f A B)&lt;/code&gt; is just like the function call &lt;code&gt;(f A B)&lt;/code&gt; in Racket&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f[A B]&lt;/code&gt; is the same as &lt;code&gt;@(f A B)&lt;/code&gt;, but typically more useful because &amp;hellip;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f[A B]{....}&lt;/code&gt; evaluates the &lt;code&gt;....&lt;/code&gt; in &amp;ldquo;text mode&amp;rdquo; to a list of words &lt;code&gt;w*&lt;/code&gt;,  then calls &lt;code&gt;f&lt;/code&gt; just like &lt;code&gt;(apply f A B w*)&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f{....}&lt;/code&gt; evaluates the &lt;code&gt;....&lt;/code&gt; in &amp;ldquo;text mode&amp;rdquo; and calls &lt;code&gt;f&lt;/code&gt; with the results&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;@f|{....}|&lt;/code&gt; is similar, but the &lt;code&gt;....&lt;/code&gt; are in &amp;ldquo;unescapable text mode&amp;rdquo;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;Unescapable text mode&amp;rdquo; treats @-signs as text instead of toggling between modes.&lt;/p&gt;

&lt;h4 id="generating-html"&gt;Generating HTML&lt;/h4&gt;

&lt;p&gt;The &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt; language comes with functions that render HTML. These functions have the same name as the corresponding HTML tag.&lt;/p&gt;

&lt;p&gt;Example program:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang scribble/html
@p{Hello World}
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Running this program prints:&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;Hello World&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;No surprises.&lt;/p&gt;

&lt;p&gt;One thing that &lt;em&gt;is&lt;/em&gt; surprising is how &lt;code&gt;scribble/html&lt;/code&gt; handles tag attributes. Every tag-rendering function accepts &amp;ldquo;Racket mode&amp;rdquo; arguments that specify  an attribute name and attribute value.&lt;/p&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang scribble/html
@p[style: "color:red"]{Hello World}
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Prints:&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;style=&lt;/span&gt;&lt;span class="s"&gt;"color:red"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Hello World&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Hope the output looks familiar. The input syntax is strange, but that&amp;rsquo;s what it is.&lt;/p&gt;

&lt;p&gt;Larger programs print larger webpages. Each page on the PRL website is HTML generated by one &lt;code&gt;scribble/html&lt;/code&gt; program.&lt;/p&gt;

&lt;h2 id="why-scribblehtml-is-an-improvement"&gt;Why &lt;code&gt;scribble/html&lt;/code&gt; is an Improvement&lt;/h2&gt;

&lt;p&gt;Before &lt;code&gt;scribble/html&lt;/code&gt;, the PRL website was implemented in &lt;code&gt;scribble/text&lt;/code&gt;. A &lt;code&gt;scribble/text&lt;/code&gt; program renders and prints text. There is no extra support for HTML.&lt;/p&gt;

&lt;p&gt;To compare, here&amp;rsquo;s the start of the old homepage:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang scribble/text
@(require "templates.rkt")

&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;
  @(header "Home")
  &amp;lt;body id="pn-top"&amp;gt;
    @(navbar "Home")
    &amp;lt;div class="jumbotron"&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;And here is the start of the &lt;code&gt;scribble/html&lt;/code&gt;&amp;rsquo;d homepage:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8
9&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang scribble/html
@require["templates.rkt"]

@doctype{html}
@html[lang: "en"]{
  @header{Home}
    @body[id: "pn-top"]{
      @navbar{Home}
      @div[class: "jumbotron"]{
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The pages look similar. The new one has more @-signs and parentheses, the old one has more &lt;code&gt;&amp;lt;&lt;/code&gt;-signs  and quotes. If you were able to edit the old page, you should be able to edit the new page.&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;key improvement&lt;/strong&gt; in the new page is that &lt;strong&gt;common mistakes are now  compile-time errors&lt;/strong&gt;.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Before, a typo like &lt;code&gt;&amp;lt;hmtl&amp;gt;&lt;/code&gt; would generate an ugly webpage.  After, a typo like &lt;code&gt;@hmtl&lt;/code&gt; is a syntax error.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Before, a typo like &lt;code&gt;&amp;lt;b&amp;gt;....&lt;/code&gt; with no closing tag would generate an ugly webpage.  After, a typo like &lt;code&gt;@b{....&lt;/code&gt; is a syntax error.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Both flavors of error message come with source-code line numbers. This is very very helpful.&lt;/p&gt;

&lt;h3 id="small-improvements"&gt;Small Improvements&lt;/h3&gt;

&lt;h4 id="1-more-functions"&gt;1. More Functions&lt;/h4&gt;

&lt;p&gt;Before, the &lt;a href="http://prl.ccs.neu.edu/teaching.html"&gt;Teaching page&lt;/a&gt; contained  some interesting HTML for rendering vertical text (look for the word &amp;ldquo;Semantics&amp;rdquo; to see how this was used):&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"how-to-design-programs"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;S&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;e&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;m&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;a&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;n&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;t&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;i&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;c&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;s&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;/span&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;After, the same text is generated from a function call:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;@span[class: "how-to-design-programs"]{@vertical-text{Semantics}}
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;vertical-text&lt;/code&gt; function is simple:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;@require[(only-in racket/list add-between)]

@(define (vertical-text . str*)
   (add-between (string-&amp;gt;list (append* str*)) (br)))
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="2-more-structure-less-boilerplate"&gt;2. More Structure, Less Boilerplate&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s part of the old definition of &amp;ldquo;Ben Greenman&amp;rdquo; on the &lt;a href="http://prl.ccs.neu.edu/people.html"&gt;People page&lt;/a&gt;:&lt;/p&gt;

&lt;div class="brush: html"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"row pn-person"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-12 pn-row-eq-height"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-3 pn-photo"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"img-wrapper"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;img&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"img/ben_greenman.jpg"&lt;/span&gt; &lt;span class="na"&gt;title=&lt;/span&gt;&lt;span class="s"&gt;"Ben Greenman"&lt;/span&gt; &lt;span class="na"&gt;alt=&lt;/span&gt;&lt;span class="s"&gt;"Ben Greenman"&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-9"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-4 pn-contact"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;span&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"pn-name"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Ben Greenman&lt;span class="nt"&gt;&amp;lt;/span&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        Advisor: Matthias Felleisen&lt;span class="nt"&gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"mailto:types@"&lt;/span&gt;&lt;span class="err"&gt;@"&lt;/span&gt;&lt;span class="na"&gt;ccs&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;neu&lt;/span&gt;&lt;span class="err"&gt;.&lt;/span&gt;&lt;span class="na"&gt;edu&lt;/span&gt;&lt;span class="err"&gt;"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;types@"@"ccs.neu.edu&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"http://www.ccs.neu.edu/home/types"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;www.ccs.neu.edu/home/types&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-3 pn-muted col-md-offset-5"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        Joined 2014
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"col-md-12 pn-bio"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;I like constructions .... &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The new definition uses a helper function with keyword arguments for each  &amp;ldquo;field&amp;rdquo; of the person:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4
5
6
7
8&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;@person[#:name "Ben Greenman"
        #:title "Advisor: Matthias Felleisen"
        #:e-mail "types@ccs.neu.edu"
        #:website "http://ccs.neu.edu/home/types"
        #:history @list["Joined 2014"]
        #:img "ben_greenman.jpg"]{
  I like constructions ....
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="3-less-string-formatting"&gt;3. Less String-Formatting&lt;/h4&gt;

&lt;p&gt;Before, the code did a lot of string formatting (&lt;a href="https://github.com/nuprl/website/commit/a0600d#diff-1921e33ce89be28dd277cf1c7880d1beL9"&gt;link&lt;/a&gt;):&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;(define (link url body)
  (string-append "&amp;lt;a href=\"" url "\"&amp;gt;" body "&amp;lt;/a&amp;gt;"))
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;The new code has no need for such helper functions.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;@a[href: url body]
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="bottom-line"&gt;Bottom Line&lt;/h4&gt;

&lt;p&gt;Scribble is a good language for making static HTML pages.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://docs.racket-lang.org/pollen/index.html"&gt;Pollen&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/vishesh/racketscript"&gt;RacketScript&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;Other websites built using &lt;a href="http://docs.racket-lang.org/scribble-pp/html.html"&gt;&lt;code&gt;scribble/html&lt;/code&gt;&lt;/a&gt;:  (1) &lt;a href="http://nanopass.org/"&gt;nanopass.github.io&lt;/a&gt; (&lt;a href="https://github.com/nanopass/nanopass.github.io"&gt;source code&lt;/a&gt;),  (2) &lt;a href="http://prl.ccs.neu.edu/gtp/"&gt;Gradual Typing Across the Spectrum&lt;/a&gt; (&lt;a href="https://github.com/nuprl/gtp"&gt;source code&lt;/a&gt;).&lt;/li&gt;
 &lt;li&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/05/18/gradual-typing-across-the-spectrum/"&gt;Notes from a Gradual Typing Across the Spectrum PI meeting&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Artifacts for Semantics</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/15/artifacts-for-semantics?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-15-artifacts-for-semantics</guid>
   <pubDate>Mon, 15 May 2017 10:08:31 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;&lt;a href="http://gallium.inria.fr/~scherer/"&gt;Gabriel Scherer&lt;/a&gt; and I recently wrote an &lt;a href="https://dbp.io/artifacts/funtal"&gt;artifact&lt;/a&gt; for a semantics &lt;a href="https://dbp.io/pubs/2017/funtal.pdf"&gt;paper&lt;/a&gt; on a typed assembly language interoperating with a high-level functional language.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;We wrote a interpreter, typechecker, and parser in OCaml, compiled it to Javascript using &lt;a href="http://ocsigen.org/js_of_ocaml/"&gt;js_of_ocaml&lt;/a&gt;, and then put it on a webpage (with an editor with syntax highlighting and error reporting) that allows people to step through examples from the paper or write their own. (Feel free to start by playing a bit with &lt;a href="https://dbp.io/artifacts/funtal"&gt;our artifact&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;This post will summarize the different parts to make it easier for others to repeat this process. We think it was a total success, and have gotten feedback that it makes understanding the (somewhat complex) language from the paper much easier. We argue that building such interpreters / typecheckers is easy enough that all papers should do this. Further, while our interpreter / typechecker is completely unverified, since we wrote it in OCaml, this approach should work equally well for semantics verified in Coq and then extracted to OCaml.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;The paper in question, &lt;a href="https://dbp.io/pubs/2017/funtal.pdf"&gt;FunTAL: Reasonably Mixing a Functional Language with Assembly&lt;/a&gt; (to appear in PLDI17), presents a multi-language that incorporates a typed assembly language (TAL) and a simple functional language where each can be embedded within the other. The paper then develops a logical relation that can be used to reason about the equivalence of such mixed programs. For example in the paper we show an imperative register-based factorial and a functional factorial equivalent.&lt;/p&gt;

&lt;p&gt;Both the static and dynamic semantics are relatively complex. The typed assembly has registers (which store word-sized values), a heap (which stores code-blocks and tuples), and a stack (not a call-stack, simply a place where word-sized values can be pushed and popped). Code-blocks have pre-conditions on the state of the registers and the stack, and allow the tail of the stack to be abstracted over polymorphically. This allows values to be protected on the stack before jumping to blocks that otherwise could change them. This is used, along with a novel notion of &lt;strong&gt;return markers&lt;/strong&gt;, to ensure well-bracketing in the control flow of the typed assembly. The return markers indicate the location that points to the block that will eventually be returned to (assuming it doesn&amp;rsquo;t loop infinitely). At the top level, the return marker &lt;code&gt;end&lt;/code&gt; indicates that, assuming it does not loop, eventually the program will stop, rather than returning somewhere else.&lt;/p&gt;

&lt;p&gt;Understanding the dynamic semantics requires tracking how values flow through the registers, the heap, and the stack, and rather than a call-stack, the user has to track the control flow through the statically-enforced return markers. This allows a good deal of low-level control-flow while still ensuring that calls will eventually return to the right place. This well-bracketing is vital to be able to reason about &amp;ldquo;components&amp;rdquo; that eventually return a value of a particular type, a necessity when embedding these components in a typed high-level program! However, it does mean that understanding the static and dynamic semantics from a few rules alone is a tall order. Our functional language is more standard, though we use (iso)-recursive types to allow recursion, which can easily trip up people, especially when you don&amp;rsquo;t have a type-checker to catch typos!&lt;/p&gt;

&lt;p&gt;For that reason, when working through examples for the paper I implemented a simple interpreter for the multi-language. I did this in OCaml, in the most straightforward way possible: by translating the definitions from the paper into type definitions (&lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L835"&gt;for F&lt;/a&gt; and &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L1209"&gt;for TAL&lt;/a&gt;), and the reduction relation into a &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L1155"&gt;&amp;ldquo;step&amp;rdquo; function&lt;/a&gt; that (assuming it wasn&amp;rsquo;t stuck or a value), did one step of evaluation. Later, I did the same thing for the type-checker, translating rules into a &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/ftal.ml#L282"&gt;type-checking function&lt;/a&gt;. The latter had to deviate from the rules in the paper in a few minor ways, as the typing rules we had in the paper were slightly not syntax directed.&lt;/p&gt;

&lt;p&gt;Having the interpreter and type-checker was very useful for me, as I could check that the examples from the paper did not contain typos, but it was much less useful as an artifact for a reader of the paper. To use it the reader would have to download the source, install OCaml, write out examples as OCaml data constructors in a test file, compile it, run it, and then interpret the (quite overwhelming) output of every step of evaluation. At each step, I printed the current registers, current stack, current heap, what the evaluation context was (as you might be evaluating TAL instructions that were embedded inside a functional program that, in turn, was embedded in further TAL instructions), and what the current reduction was.&lt;/p&gt;

&lt;p&gt;To get from that useful-for-the-authors artifact to a useful-to-readers artifact requires doing three things:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Allow reading/writing programs in a notation as close to the paper as  possible. In our paper we use superscripts, subscripts, and a few greek  letters, but ended up with a syntax otherwise very close to the paper &amp;mdash; the biggest  differences were a few extra delimiters introduced to reduce ambiguity.&lt;/li&gt;
 &lt;li&gt;Present an interface that highlights type errors at the location they  occurred in, and allow a reader to step forward and backwards through the  evaluation. Printing console output traces is fine for authors, but adds too  much effort for readers.&lt;/li&gt;
 &lt;li&gt;Put it online! Don&amp;rsquo;t require installing any software! Conveniently,  implementing 2 is also made easier once done online, as we could use existing  editor tooling to present the code, highlight errors, etc. By using OCaml, we  were able to easily use the  excellent &lt;a href="http://ocsigen.org/js_of_ocaml/"&gt;js_of_ocaml&lt;/a&gt;.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;The first was done by Gabriel, who wrote a grammar using &lt;a href="http://gallium.inria.fr/~fpottier/menhir/"&gt;Menhir&lt;/a&gt;, and then equipped it with custom parsing error messages that provide much better feedback when there are typos in what people are trying. We also wrote a pretty-printer using the &lt;a href="http://gallium.inria.fr/blog/first-release-of-pprint/"&gt;PPrint&lt;/a&gt; library, so we could show intermediate program states through the UI. After writing this, we were able to convert our existing suite of test cases and examples to be written textually, which was a huge improvement for us as well! These and other tests were used to ensure that the parser/pretty-printer would round-trip properly.&lt;/p&gt;

&lt;p&gt;For the interface, I built a simple web page that had the &lt;a href="https://codemirror.net/"&gt;CodeMirror&lt;/a&gt; editor equipped with a very simple syntax highlighter (&lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/artifact/index.html#L247"&gt;8 lines of code&lt;/a&gt; to highlight keywords &amp;amp; atoms, plus a CodeMirror extension to highlight matching brackets) and error highlighting (which is triggered by the OCaml code). I then made a simple &amp;ldquo;machine state&amp;rdquo; UI that showed, in pretty-printed format, the heap, stack, registers, context, and redex. On the OCaml side, when the &amp;ldquo;run&amp;rdquo; button is clicked, we parse and typecheck and, assuming no errors occur, store the current state as our &amp;ldquo;history&amp;rdquo;. As the user clicks forward or backwards, we run the step function and append to the history of states or pop states off of the history. In total, there are &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/artifact/index.html#L246"&gt;50 lines of Javascript&lt;/a&gt; and about &lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/web.ml"&gt;150 lines of OCaml&lt;/a&gt; that handle the logic for this interactive UI.&lt;/p&gt;

&lt;p&gt;Putting it online was very easy, based on the choice of tools used earlier. We compile the main file (&lt;a href="https://github.com/dbp/funtal/blob/032be70f33f77e80f4fab7e62016bfabf96476f3/web.ml"&gt;web.ml&lt;/a&gt;) to Javascript using &lt;a href="http://ocsigen.org/js_of_ocaml/"&gt;js_of_ocaml&lt;/a&gt;, and it pulls in the parser, type-checker, interpreter, examples, etc. The rest of the artifact is a single html file, a CSS file, and a few javascript files for CodeMirror. It requires no server backend, is easy to archive and save, and will even run on smartphones!&lt;/p&gt;

&lt;p&gt;The total time spent implementing the artifact was a small fraction of the time spent on the paper (probably 15 days of person-time), and while it was not in any critical way essential for the success of the paper, it does make the paper much easier to read, and we would argue that all semantics papers would be better off with easy to use artifacts for experimentation. Also, while implementing the artifact we found a few mistakes in the typing judgments for the language. The most interesting one was for our &lt;code&gt;protect&lt;/code&gt; TAL instruction, which exists to protect the tail of the stack in a fresh type variable. We had written this as a typing rule that type-checked the rest of the instruction sequence with the abstracted tail, but this never allowed the tail to be accessed again. By translating the typing judgments exactly into code, we realized that there was a problem, because examples that should have worked did not type-check! We were then able to fix the typing rule to conform to what we originally thought it achieved &amp;mdash; locally abstracting, but not abstracting from outside the component. What is interesting is that this did not come up in our proofs because the typing rule was perfectly valid &amp;mdash; it just did not allow non-trivial programs that used the &lt;code&gt;protect&lt;/code&gt; instruction. It&amp;rsquo;s quite possible we would have noticed this without implementing the artifact, but the artifact certainly made it easier!&lt;/p&gt;

&lt;p&gt;To see the artifact online, visit:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://dbp.io/artifacts/funtal"&gt;https://dbp.io/artifacts/funtal&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The source code is at:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/dbp/funtal/tree/032be70f33f77e80f4fab7e62016bfabf96476f3"&gt;https://github.com/dbp/funtal&lt;/a&gt;&lt;/p&gt;</description></item>
  <item>
   <title>No Good Answers, Gradually Typed Object-Oriented Languages</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/09/no-good-answers-gradually-typed-object-oriented-languages?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-09-no-good-answers-gradually-typed-object-oriented-languages</guid>
   <pubDate>Tue, 09 May 2017 14:04:31 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;Untyped code remains a real problem in practice, as a result of reduced performance and hindered readability. One approach to solve this problem is gradual typing.&lt;/p&gt;

&lt;p&gt;Gradual typing puts the onus on the developer to add type annotations, statically checks whatever type annotations have been written, and dynamically ensures that untyped code does not violate those annotations. A number of approaches have been put forward to try to achieve these objectives while retaining efficiency, semantic meaning, and the ability to actually type untyped code.&lt;/p&gt;

&lt;p&gt;I discussed three systems, all of which achieve the objective of typing untyped code in different ways, and all of which have different tradeoffs.&lt;/p&gt;

&lt;p&gt;Unofficial Notes:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-04-18.md"&gt;https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-04-18.md&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Code Examples:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/BenChung/GradualComparison/tree/master/examples/HOPL"&gt;https://github.com/BenChung/GradualComparison/tree/master/examples/HOPL&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Rank Polymorphism</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/04/rank-polymorphism?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-04-rank-polymorphism</guid>
   <pubDate>Thu, 04 May 2017 18:26:48 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Rank polymorphism gives you code reuse on arguments of different dimensions. Take a linear interpolation function (let&amp;rsquo;s just call it &lt;code&gt;lerp&lt;/code&gt;) for scalars:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Œª ((lo 0) (hi 0) (Œ± 0)) (+ (* lo (- 1 Œ±)) (* hi Œ±)))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The number marks on each argument indicate the expected &amp;ldquo;rank&amp;rdquo; of the argument: how many dimensions it should have. In this case, each one is marked &lt;code&gt;0&lt;/code&gt;, indicating a scalar (&lt;em&gt;i.e.&lt;/em&gt;, 0-dimensional) argument. The function is usable as-is for&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;Œ±-blending two RGB pixels&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;dimming or brightening an image&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;fade transition between video scenes&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;!-- more--&gt;

&lt;p&gt;Each of these use cases mixes the argument dimensions a little differently. A pixel is a vector (a rank&amp;ndash;1 structure) of numbers representing color channel values, so the Œ±-blending case uses two vector arguments and one scalar argument.&lt;/p&gt;

&lt;p&gt;The only real difference between these use cases is the iteration space: they&amp;rsquo;re all effectively loop nests around the same basic scalar operation. In a rank-polymorphic language, the iteration space is derived automatically from the data, so you don&amp;rsquo;t need to write out the control structure yourself.&lt;/p&gt;

&lt;p&gt;The fundamental idea behind function application here is breaking the argument arrays into lower-ranked pieces called &amp;ldquo;cells.&amp;rdquo; Each cell has the rank expected by the function being applied. In the case of &lt;code&gt;lerp&lt;/code&gt;, the pixels, images, videos, etc. are all broken up into rank&amp;ndash;0 (scalar) cells because &lt;code&gt;lerp&lt;/code&gt; expects rank&amp;ndash;0 arguments. Other expected ranks are possible as well‚Äî a vector dot product function &lt;code&gt;dot-prod&lt;/code&gt; would call for rank&amp;ndash;1 cells, and a matrix inversion function &lt;code&gt;minv&lt;/code&gt; would call for rank&amp;ndash;2 cells.&lt;/p&gt;

&lt;p&gt;The structure built up around the cells is called the &amp;ldquo;frame.&amp;rdquo; A matrix array is a rank&amp;ndash;2 frame containing rank&amp;ndash;0 cells for &lt;code&gt;lerp&lt;/code&gt;, but it would be a rank&amp;ndash;1 frame containing rank&amp;ndash;1 cells for &lt;code&gt;dot-prod&lt;/code&gt; and a rank&amp;ndash;0 frame containing a single rank&amp;ndash;1 cell for &lt;code&gt;minv&lt;/code&gt;. A rank-&lt;em&gt;n&lt;/em&gt; array could be broken down into a frame of cells in &lt;em&gt;n+1&lt;/em&gt; different ways, and it&amp;rsquo;s the function being applied that determines which decomposition to use.&lt;/p&gt;

&lt;p&gt;Unfortunately, the implicit control structure that&amp;rsquo;s so convenient for the programmer is a problem for a compiler. Historically, implementations of such languages have had to do without static information about the iteration space. Interpreters (and line-at-a-time compilers, to a lesser extent) get to inspect the concrete data they&amp;rsquo;re dealing with, but static compilers have had to make do with emitting a generic loop structure. A &amp;ldquo;loop&amp;rdquo; over a scalar might sound like trivial overhead, but not when it appears within some other hot loop. Being unable to see when loop boundaries match up is also a barrier to loop fusion. The lack of thorough static shape information was a long-standing problem my advisor pointed out to me when I was a new student looking at possible research projects, and he was interested in applying some form of static analysis to gather that information.&lt;/p&gt;

&lt;p&gt;The first step in addressing it was to come up with a formal semantics for rank polymorphism. Although &lt;a href="http://www.jsoftware.com/papers/APL.htm"&gt;APL has existed since the 1960s&lt;/a&gt;, it had mostly lived in a separate world from mainstream programming language research. The formal techniques developed in PL had seen little to no application to APL and its &amp;ldquo;successor&amp;rdquo; language J.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot to dislike about APL and J‚Äîspecial case behavior in many of the primitive operators, limited function arity, syntactic separation of first-order and second-order functions, the impossibility of parsing an entire program at once (fun fact: static analysis &lt;a href="http://dl.acm.org/citation.cfm?id=805380"&gt;has been tried&lt;/a&gt; there)‚Äîand of course the idiosyncratic identifiers used for primops have prompted plenty of internet arguments. None of those things are essential to the programming model, so I&amp;rsquo;m &lt;a href="http://www.ccs.neu.edu/home/jrslepak/proposal.pdf"&gt;building a new language called Remora&lt;/a&gt; to isolate the aspects I want to study.&lt;/p&gt;

&lt;p&gt;People don&amp;rsquo;t always think of a type system as a form of static analysis, but it turned out to be an effective way of gathering shape information. Remora&amp;rsquo;s &lt;a href="http://www.ccs.neu.edu/home/jrslepak/esop14-full.pdf"&gt;type system&lt;/a&gt; uses a restricted form of dependent types, in the style of &lt;a href="https://www.cs.cmu.edu/~rwh/theses/xi.pdf"&gt;Dependent ML&lt;/a&gt;. An array type is indexed by the shape, the numeric sizes of the array&amp;rsquo;s individual dimensions. Index polymorphism (&lt;em&gt;i.e.&lt;/em&gt;, Œ† types) allows functions to work on varying cell shapes and even varying cell ranks (which is essential for primitives like &lt;code&gt;append&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt;, which operate along the major axis of arrays, no matter their rank). Frame-rank polymorphism, which gives rise to the control structure, remains completely implicit, leaving it to be identified by the type rule for function application. As a nice bonus, type soundness rules out run-time errors arising from incompatible argument shapes.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/10/19/history-of-actors/"&gt;History of Actors&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2017/02/21/datalog-for-static-analysis/"&gt;Datalog for Static Analysis&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Categorical Semantics for Dynamically Typed Programming Languages</title>
   <link>http://prl.ccs.neu.edu/blog/2017/05/01/categorical-semantics-for-dynamically-typed-programming-languages?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-05-01-categorical-semantics-for-dynamically-typed-programming-languages</guid>
   <pubDate>Mon, 01 May 2017 12:25:17 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;In 1969, Dana Scott wrote an &lt;a href="/blog/static/scott-69-93-type-theoretical-alternative.pdf"&gt;unpublished manuscript&lt;/a&gt; in which he said untyped lambda calculus had no mathematical meaning, 11 years later he wrote &lt;a href="/blog/static/scott-80-relating-theories.pdf"&gt;a paper&lt;/a&gt; that organized many of the different semantics he and others had since found using the language of category theory.&lt;/p&gt;

&lt;p&gt;This latter paper is really the first deserving of the title &amp;ldquo;categorical semantics of dynamic typing&amp;rdquo;, and so I&amp;rsquo;m going to present some of the theorems and &amp;ldquo;theorems&amp;rdquo; presented in that paper, but mingled with the history of the idea and the preceding papers that led to them.&lt;/p&gt;

&lt;p&gt;&lt;a href="/blog/static/dyn-cats.pdf"&gt;My Full Notes&lt;/a&gt; continue the story, and you might also be interested in the &lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-04-07.md"&gt;discussion during the lecture&lt;/a&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>What is Soft Typing?</title>
   <link>http://prl.ccs.neu.edu/blog/2017/04/28/what-is-soft-typing?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-04-28-what-is-soft-typing</guid>
   <pubDate>Fri, 28 Apr 2017 12:25:17 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;A soft type system rewrites programs and meets a few &lt;em&gt;design criteria&lt;/em&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id="what-are-the-design-criteria"&gt;What are the Design Criteria?&lt;/h2&gt;

&lt;p&gt;According to Mike Fagan&amp;rsquo;s 1991 &lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/soft-typing/papers"&gt;dissertation&lt;/a&gt;,  a soft type system must:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;accept all &lt;em&gt;syntactically correct&lt;/em&gt; programs as input;&lt;/li&gt;
 &lt;li&gt;produce equivalent, &lt;em&gt;memory-safe&lt;/em&gt; programs as output; and&lt;/li&gt;
 &lt;li&gt;be &lt;em&gt;unobtrusive&lt;/em&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="important-details"&gt;Important details:&lt;/h3&gt;

&lt;ul&gt;
 &lt;li&gt;In this context, &lt;em&gt;memory safe&lt;/em&gt; basically means &amp;ldquo;no segfaults&amp;rdquo;.  Programs output by a soft type system should be as safe as statically-typed  Java programs or dynamically-typed Python programs.&lt;/li&gt;
 &lt;li&gt;Fagan characterizes &lt;em&gt;unobtrusive&lt;/em&gt; with two general principles:&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;minimal text principle&lt;/em&gt; : the type checker should work without any programmer-supplied annotations&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;minimal failure principle&lt;/em&gt; : the type checker should assign &lt;em&gt;useful&lt;/em&gt; types to &lt;em&gt;idiomatic&lt;/em&gt; programs  (basically, don&amp;rsquo;t just say that every expression has &amp;ldquo;unknown&amp;rdquo; or &amp;ldquo;top&amp;rdquo; type)&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="why-would-i-want-to-use-a-soft-type-system"&gt;Why would I want to use a soft type system?&lt;/h2&gt;

&lt;p&gt;If you:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;like dynamic typing&lt;/li&gt;
 &lt;li&gt;want some &lt;em&gt;benefits&lt;/em&gt; of static typing&lt;/li&gt;
 &lt;li&gt;refuse to (or &lt;em&gt;cannot&lt;/em&gt;!) change your code to satisfy a type checker&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;then Soft Typing is a perfect fit. You just need to find/build a soft type checker.&lt;/p&gt;

&lt;h3 id="clarification"&gt;Clarification&lt;/h3&gt;

&lt;p&gt;The &lt;em&gt;benefits&lt;/em&gt; of static typing that a soft type system can give are:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;early detection of typos and simple logical errors&lt;/li&gt;
 &lt;li&gt;documentation, through (inferred) type signatures&lt;/li&gt;
 &lt;li&gt;speed, when the types can justify removing a runtime safety check&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;See Andrew Wright&amp;rsquo;s 1994 &lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/soft-typing/papers"&gt;dissertation&lt;/a&gt; for proof.&lt;/p&gt;

&lt;h2 id="can-i-use-andrew-wrights-soft-type-system"&gt;Can I use Andrew Wright&amp;rsquo;s soft type system?&lt;/h2&gt;

&lt;p&gt;Not sure, but you may download the code for it:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/softscheme"&gt;https://github.com/nuprl/softscheme&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h2 id="please-explain-fagans--wrights-soft-types"&gt;Please explain Fagan&amp;rsquo;s / Wright&amp;rsquo;s soft types&lt;/h2&gt;

&lt;p&gt;Types &lt;code&gt;t&lt;/code&gt; are made of constructors &lt;code&gt;k&lt;/code&gt;, flags &lt;code&gt;f&lt;/code&gt;, and type variables &lt;code&gt;a&lt;/code&gt;. The grammar for types is basically:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  t ::= a | (k f t ...) U t
  k ::= Int | Pair | -&amp;gt;
  f ::= ++ | -- | b
  a ::= a0 | a1 | a2 | a3 | ....
  b ::= b0 | b1 | b2 | b3 | ....&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;where:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;U&lt;/code&gt; is just a symbol, represents &amp;ldquo;union&amp;rdquo;&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;a&lt;/code&gt; is a type variable; there are infinitely many type variables&lt;/li&gt;
 &lt;li&gt;&lt;code&gt;b&lt;/code&gt; is a flag variable; the set of flag variables is also infinte&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;There are also some rules for types to be well-formed.&lt;/p&gt;

&lt;p&gt;Here are two well-formed types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Int ++) U a0

(-&amp;gt; ++ ((Int b0) U a1)
       ((Int ++) U a2)) U a3&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are two types that match the grammar, but are &lt;strong&gt;NOT&lt;/strong&gt; well-formed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Int ++ a0) U a1

(-&amp;gt; --) U a2&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, some intuition:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;A constructor &lt;code&gt;k&lt;/code&gt; is like a behavior,&lt;/li&gt;
 &lt;li&gt;a type &lt;em&gt;describes&lt;/em&gt; the behaviors a value can have.&lt;/li&gt;
 &lt;li&gt;The description is like a bitvector of &amp;ldquo;yes&amp;rdquo;, &amp;ldquo;no&amp;rdquo;, or &amp;ldquo;maybe&amp;rdquo; for each possible behavior.&lt;/li&gt;
 &lt;li&gt;A flag variable is the way to say &amp;ldquo;maybe&amp;rdquo;.&lt;/li&gt;
 &lt;li&gt;Every type ends with a type variable because every typed expression might  flow to a context that expects a more general type.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The type and flag variables let Fagan and Wright encode subtyping using  polymorphism. It&amp;rsquo;s a very cool idea, introduced in Didier Remy&amp;rsquo;s  &lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/soft-typing/papers"&gt;POPL 1989 paper&lt;/a&gt;. But it adds a learning curve, and has some drawbacks for type inference.&lt;/p&gt;

&lt;h2 id="stream-of-consciousness-notes-from-the-hopl-lecture"&gt;Stream-of-consciousness notes from the HOPL lecture&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="/blog/static/soft-typing.pdf"&gt;Local copy&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/soft-typing"&gt;Source of Truth&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>PRL at SNAPL'17</title>
   <link>http://prl.ccs.neu.edu/blog/2017/04/25/prl-at-snapl-17?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-04-25-prl-at-snapl-17</guid>
   <pubDate>Tue, 25 Apr 2017 16:46:54 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;PRL recently produced three papers for the &lt;a href="http://snapl.org/2017/index.html"&gt;SNAPL&lt;/a&gt; conference.&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://dbp.io/pubs/2017/linking-types-snapl.pdf"&gt;Linking Types for Multi-Language Software: Have Your Cake and Eat  It Too&lt;/a&gt;, by Daniel  Patterson and Amal Ahmed.&lt;/li&gt;
 &lt;li&gt;&lt;a href="http://www.ccs.neu.edu/home/gasche/research/canonical-forms/snapl.pdf"&gt;Search for Program Structure&lt;/a&gt;,  by Gabriel Scherer&lt;/li&gt;
 &lt;li&gt;&lt;a href="http://www.ccs.neu.edu/racket/pubs/typed-racket.pdf"&gt;Migratory Typing: Ten Years  Later&lt;/a&gt;, by Sam  Tobin-Hochstadt, Matthias Felleisen, Robert Bruce Findler, Matthew  Flatt, Ben Greenman, Andrew M. Kent, Vincent St-Amour, T. Stephen  Strickland and Asumu Takikawa&lt;/li&gt;&lt;/ul&gt;
&lt;!-- more--&gt;

&lt;h3 id="httpsdbpiopubs2017linking-types-snaplpdflinking-types-for-multi-language-software-have-your-cake-and-eat--it-too"&gt;&lt;a href="https://dbp.io/pubs/2017/linking-types-snapl.pdf"&gt;Linking Types for Multi-Language Software: Have Your Cake and Eat  It Too&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Daniel Patterson and Amal Ahmed, 2017&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;Software developers compose systems from components written in many different languages. A business-logic component may be written in Java or OCaml, a resource-intensive component in C or Rust, and a high-assurance component in Coq. In this multi-language world, program execution sends values from one linguistic context to another. This boundary-crossing exposes values to contexts with unforeseen behavior‚Äîthat is, behavior that could not arise in the source language of the value. For example, a Rust function may end up being applied in an ML context that violates the memory usage policy enforced by Rust‚Äôs type system. This leads to the question of how developers ought to reason about code in such a multi-language world where behavior inexpressible in one language is easily realized in another.&lt;/p&gt;
 &lt;p&gt;This paper proposes the novel idea of linking types to address the problem of reasoning about single-language components in a multi-lingual setting. Specifically, linking types allow programmers to annotate where in a program they can link with components inexpressible in their unadulterated language. This enables developers to reason about (behavioral) equality using only their own language and the annotations, even though their code may be linked with code written in a language with more expressive power.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="httpwwwccsneueduhomegascheresearchcanonical-formssnaplpdfsearch-for-program-structure"&gt;&lt;a href="http://www.ccs.neu.edu/home/gasche/research/canonical-forms/snapl.pdf"&gt;Search for Program Structure&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Gabriel Scherer, 2017.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The community of programming language research loves the Curry-Howard correspondence between proofs and programs. Cut-elimination as computation, theorems for free, &amp;lsquo;call/cc&amp;rsquo; as excluded middle, dependently typed languages as proof assistants, etc.&lt;/p&gt;
 &lt;p&gt;Yet we have, for all these years, missed an obvious observation: &amp;ldquo;the structure of &lt;em&gt;programs&lt;/em&gt; corresponds to the structure of proof &lt;em&gt;search&lt;/em&gt;&amp;rdquo;. For pure programs and intuitionistic logic, more is known about the latter than the former. We think we know what programs are, but logicians know better!&lt;/p&gt;
 &lt;p&gt;To motivate the study of proof search for program structure, we retrace recent research on applying the logical technique of focusing to study the canonical structure of simply-typed Œª-terms. We then motivate the open problem of extending canonical forms to support richer type systems, such as polymorphism, by discussing a few enticing applications of more canonical program representations.&lt;/p&gt;&lt;/blockquote&gt;

&lt;h3 id="httpwwwccsneueduracketpubstyped-racketpdfmigratory-typing-ten-years-later"&gt;&lt;a href="http://www.ccs.neu.edu/racket/pubs/typed-racket.pdf"&gt;Migratory Typing: Ten Years Later&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Sam Tobin-Hochstadt, Matthias Felleisen, Robert Bruce Findler, Matthew Flatt, Ben Greenman, Andrew M. Kent, Vincent St-Amour, T. Stephen Strickland and Asumu Takikawa, 2017.&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;In this day and age, many developers work on large, untyped code repositories. Even if they are the creators of the code, they notice that they have to figure out the equivalent of method signatures every time they work on old code. This step is time consuming and error prone.&lt;/p&gt;
 &lt;p&gt;Ten years ago, the two lead authors outlined a linguistic solution to this problem. Specifically they proposed the creation of typed twins for untyped programming languages so that developers could migrate scripts from the untyped world to a typed one in an incremental manner. Their programmatic paper also spelled out three guiding design principles concerning the acceptance of grown idioms, the soundness of mixed-typed programs, and the units of migration.&lt;/p&gt;
 &lt;p&gt;This paper revisits this idea of a migratory type system as implemented for Racket. It explains how the design principles have been used to produce the Typed Racket twin and presents an assessment of the project‚Äôs status, highlighting successes and failures.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;.&lt;/p&gt;

&lt;p&gt;SNAPL is not dissimilar to the (french-speaking) &lt;a href="http://jfla.inria.fr/"&gt;JFLA&lt;/a&gt; that I am more familiar with &amp;mdash; with an added irritating call for paper and unreasonable registration price. It has an interesting diversity of topics of presentation: see also the complete &lt;a href="http://snapl.org/2017/papers.html"&gt;list of accepted papers&lt;/a&gt; this year, and the &lt;a href="http://snapl.org/2015/papers.html"&gt;list of the previous edition&lt;/a&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Refinement Types</title>
   <link>http://prl.ccs.neu.edu/blog/2017/04/20/refinement-types?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-04-20-refinement-types</guid>
   <pubDate>Thu, 20 Apr 2017 23:38:23 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;Roughly, a refinement type system is an extra layer of precision, enforced through subtyping, added onto an existing type system. A base type is decomposed into a set of &lt;em&gt;base refinements&lt;/em&gt;, each of which denotes a subset of the values belonging to the base type. A subtyping relation respecting set inclusion can then be defined among the refinements of the base type. These subtyping relations can be lifted onto a subtyping relation for compound types using a standard arrow subtyping rule.&lt;/p&gt;

&lt;p&gt;Extra type-checking precision sounds great, but what in practical terms does this precision look like? Freeman and Pfenning&amp;rsquo;s &amp;rsquo;92 paper &lt;em&gt;Refinement Types for ML&lt;/em&gt; proposes extending ML&amp;rsquo;s type definition language with constructs for decomposing a discriminated union type into a lattice of subtypes. For example, it allows the decomposition of a list type into a lattice including base refinements for empty lists, non-empty lists, and singletons. Those with experience in functional programming will realize this alleviates the dreaded and inescapable ‚Äúnon-exhaustive pattern match‚Äù warning, which tends to crop up in situations where the programmer understands that an exhaustive pattern match is not necessary.&lt;/p&gt;

&lt;p&gt;In the late 90&amp;rsquo;s Xi and Pfenning advanced the state of refinement types by introducing a dependent refinement type system, implemented as a tool called Dependent ML. Their approach identifies a base refinement using a tuple of terms drawn from some computationally tractable constraint language called an &lt;em&gt;index language&lt;/em&gt;. A list datatype can then be refined with a term of the &lt;em&gt;linear integer arithmetic&lt;/em&gt; index language, denoting the subset of all lists having a specific length. One list refinement is then considered a subtype of another when a constraint solver can prove their index terms equal. Vazou et. al.&amp;rsquo;s recent project Liquid Haskell is another dependent refinement type system which decides subtyping among base types by invoking an SMT solver under a context-dependent set of constraints. It differs significantly from Dependent ML in that it refines base types with certain well-behaved program terms rather than indices.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Resources:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="/blog/static/refinement_types_lecture.pdf"&gt;Full Notes&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="/blog/static/refinement_types_bib.pdf"&gt;Annotated Bibliography&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/refinement-types"&gt;GitHub&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Type-Directed Compilation, Parts I and II</title>
   <link>http://prl.ccs.neu.edu/blog/2017/04/17/type-directed-compilation-parts-i-and-ii?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-04-17-type-directed-compilation-parts-i-and-ii</guid>
   <pubDate>Mon, 17 Apr 2017 12:00:17 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;h3 id="part-i-type-directed-compilation-by-leif-andersen"&gt;Part I: &lt;em&gt;Type-Directed Compilation&lt;/em&gt;, by Leif Andersen.&lt;/h3&gt;

&lt;p&gt;In this talk we discuss the history of type directed compilation. We start with Xavier Leroy&amp;rsquo;s seminal paper: &lt;a href="http://gallium.inria.fr/~xleroy/publi/unboxed-polymorphism.pdf"&gt;&lt;em&gt;Unboxed Objects and Polymorphic Typing&lt;/em&gt;&lt;/a&gt;, continue to &lt;a href="https://www.cs.cmu.edu/~rwh/papers/til/pldi96.pdf"&gt;TIL&lt;/a&gt; (Typed Intermediate Language), and finish up with &lt;a href="https://dash.harvard.edu/handle/1/2797451"&gt;TAL&lt;/a&gt; (Typed Assembly Language). We talk about what it means for a compiler to be typed preserving, and give examples of optimizations that are enabled by types.&lt;/p&gt;

&lt;p&gt;Discussion summary:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-03-24.md"&gt;https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017&amp;ndash;03&amp;ndash;24.md&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;h3 id="part-ii-dependent-type-directed-compilation-by-william-j-bowman"&gt;Part II: &lt;em&gt;Dependent Type-Directed Compilation&lt;/em&gt;, by William J. Bowman&lt;/h3&gt;

&lt;p&gt;A certifying compiler is not verified, but it produces a proof of correctness for each binary. This proof can be independently checked to show that the binary was compiled correctly, removing the compiler from the trusted code base. Certifying compilation has its roots in preserving type-preserving compilation, and in particular in preserving dependent types. We start the history of dependent-type-preserving compilation with a compiler from C to Assembly. We&amp;rsquo;ll see a result showing that preserving dependent types isn&amp;rsquo;t possible, and then we&amp;rsquo;ll do it anyway.&lt;/p&gt;

&lt;p&gt;Discussion summary:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-03-28.md"&gt;https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017&amp;ndash;03&amp;ndash;28.md&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Notes (to appear here, eventually):&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/dependent-type-preserving-compilation"&gt;https://github.com/nuprl/hopl-s2017/blob/master/dependent-type-preserving-compilation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Top Five Results of the Past 50 Years of Programming Languages Research</title>
   <link>http://prl.ccs.neu.edu/blog/2017/04/04/top-five-results-of-the-past-50-years-of-programming-languages-research?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-04-04-top-five-results-of-the-past-50-years-of-programming-languages-research</guid>
   <pubDate>Tue, 04 Apr 2017 10:21:36 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;Over the past 50 years, which result from programming languages research has had the greatest impact on working programmers?&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;The center of the universe for a working programmer is the language (or languages) they use. Fundamental results in programming languages (PL) research can re-shape this universe.&lt;/p&gt;

&lt;p&gt;In &lt;a href="http://www.ccs.neu.edu/home/matthias/7480-s17/index.html"&gt;HOPL&lt;/a&gt; two weeks ago, Matthias claimed that &lt;em&gt;type soundness&lt;/em&gt; is the most useful and influential result to flow from PL research to PL practice in the last 50 years.&lt;/p&gt;

&lt;p&gt;But 50 years is a long time, and there are many serious contenders for the title of &lt;em&gt;greatest PL result&lt;/em&gt;. Here are my (alphabetized) picks for the top five:&lt;/p&gt;

&lt;h3 id="abstraction"&gt;Abstraction&lt;/h3&gt;

&lt;blockquote&gt;
 &lt;p&gt;My goal in library design is this; I want to have a precise, elegant, re-usable abstraction &amp;mdash;Conal Eliott, &lt;a href="https://www.youtube.com/watch?v=zzCrZEil9iI"&gt;BayHac 2014 (00:01:55)&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;By &lt;em&gt;abstraction&lt;/em&gt;, I mean anything whose interface is not just &amp;ldquo;read the implementation&amp;rdquo;. Could be a tuple, module, object, structure, semaphore, macro, etc. Even the memory hierarchy pyramid in your operating systems textbook is an abstraction. They are everywhere, and they are what separates computer science (it&amp;rsquo;s about &lt;em&gt;ideas&lt;/em&gt;) from electrical engineering (it&amp;rsquo;s about &lt;em&gt;transistors&lt;/em&gt;). Thank you &lt;a href="/img/l-plp-1965.pdf"&gt;Peter Landin&lt;/a&gt; and &lt;a href="/img/m-thesis-1969.pdf"&gt;J.H. Morris&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="generational-garbage-collection"&gt;Generational Garbage Collection&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t know much about garbage collection. I do know that I want it, and I&amp;rsquo;m pretty sure that I wouldn&amp;rsquo;t have it (outside of research languages) without generational garbage collection. Thank you &lt;a href="/img/u-sde-1984.pdf"&gt;David Ungar&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="generic-programming"&gt;Generic Programming&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;a.k.a. the mainstream interpretations of parametric polymorphism&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The thought of programming in Java 1.4 is terrifying. Thank you &lt;a href="/img/g-thesis-1972.pdf"&gt;Jean-Yves Girard&lt;/a&gt; and &lt;a href="/img/r-cp-1974.pdf"&gt;John C. Reynolds&lt;/a&gt; and &lt;a href="http://homepages.inf.ed.ac.uk/wadler/gj/"&gt;Gilad Bracha and Martin Odersky and David Stoutamire and Philip Wadler&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="modularization"&gt;Modularization&lt;/h3&gt;

&lt;p&gt;How can humans understand large software systems? By organizing the systems into smaller components (modules, objects) with well-defined interfaces. It&amp;rsquo;s hard to imagine, but once upon a time the question of &lt;em&gt;how&lt;/em&gt; to divide a system into modules was a new research problem. Thank you &lt;a href="/img/p-tr-1971.pdf"&gt;D.L. Parnas&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id="type-soundness"&gt;Type Soundness&lt;/h3&gt;

&lt;p&gt;Let me make two modest claims:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Soundness (with respect to a dynamic semantics) is a desirable property for a static type system.&lt;/li&gt;
 &lt;li&gt;A large number (at least, thousands) of working programmers agree that programming in a language with a sound, static type system is &amp;ldquo;a good thing&amp;rdquo;.&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;Neither of these claims were true 50 years ago. They are definitely true today. And the slogan &amp;ldquo;well typed programs do not go wrong (up to a well-defined set of runtime errors)&amp;rdquo; has become the catchphrase of PL research. Thank you &lt;a href="/img/m-jcss-1978.pdf"&gt;Robin Milner&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="honorable-mentions"&gt;Honorable Mentions&lt;/h2&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://www.paulgraham.com/thist.html"&gt;lexical scope&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="/img/d-thesis-1984.pdf"&gt;type inference&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://www.quora.com/Why-does-Kent-Beck-refer-to-the-rediscovery-of-test-driven-development"&gt;test-driven development&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://en.wikipedia.org/wiki/Simula"&gt;object-oriented programming&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="/img/ss-tr-1975.pdf"&gt;continuation passing style&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="/img/kffd-tr-1986.pdf"&gt;hygienic macros&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;If you liked this post, you may also be interested in:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://prl.ccs.neu.edu/blog/2016/05/18/gradual-typing-across-the-spectrum/"&gt;Gradual Typing Across the Spectrum&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="http://jschuster.org/blog/2016/11/29/getting-started-in-programming-languages/"&gt;Getting Started in Programming Languages&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://williamjbowman.com/blog/2017/03/24/what-even-is-compiler-correctness/"&gt;What even is compiler correctness?&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>[What even is compiler correctness? (cross-post)](https://williamjbowman.com/blog/2017/03/24/what-even-is-compiler-correctness/)</title>
   <link>http://prl.ccs.neu.edu/blog/2017/03/24/-what-even-is-compiler-correctness-cross-post-https-williamjbowman-com-blog-2017-03-24-what-even-is-compiler-correctness?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-03-24-what-even-is-compiler-correctness-cross-post-https-williamjbowman-com-blog-2017-03-24-what-even-is-compiler-correctness</guid>
   <pubDate>Fri, 24 Mar 2017 23:11:17 UT</pubDate>
   <author>PRL</author>
   <description></description></item>
  <item>
   <title>Tracing JITs for Dynamic Languages</title>
   <link>http://prl.ccs.neu.edu/blog/2017/03/15/tracing-jits-for-dynamic-languages?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-03-15-tracing-jits-for-dynamic-languages</guid>
   <pubDate>Wed, 15 Mar 2017 10:54:39 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;Traditional JIT (just-in-time) compilers are method-based: they compile &amp;ldquo;hot&amp;rdquo; (i.e. frequently executed) methods to native code. An alternative is trace-based or tracing JITs, where the compilation unit is a (hot) sequence of instructions. Typically, such sequences of instructions correspond to loops, where programs spend most of their execution time.&lt;/p&gt;

&lt;p&gt;Where did the idea of tracing come from? What was appealing about it? How was tracing adapted for JITs and dynamic languages? What happened to Mozilla&amp;rsquo;s TraceMonkey, which used to be part of Firefox? Do any JITs today use tracing?&lt;/p&gt;

&lt;p&gt;In this talk, I trace tracing JITs from their origins to some of their recent developments. I cover five papers: the original tracing paper, an implementation of a tracing JIT for Java, the TraceMonkey JIT for JavaScript, PyPy&amp;rsquo;s &amp;ldquo;meta-level&amp;rdquo; tracing, and a specific class of optimizations for tracing JITs.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(The idea of using the phrase &amp;ldquo;trace tracing JITs&amp;rdquo; is from Matthias Felleisen.)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;All materials can be found in the &lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/tracing-jit"&gt;course repository&lt;/a&gt;:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/tracing-jit/notes.pdf"&gt;Full notes&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/tracing-jit/annotated.txt"&gt;Annotated bibliography&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Type Inference in Stack-Based Programming Languages</title>
   <link>http://prl.ccs.neu.edu/blog/2017/03/10/type-inference-in-stack-based-programming-languages?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-03-10-type-inference-in-stack-based-programming-languages</guid>
   <pubDate>Fri, 10 Mar 2017 16:23:30 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;Stack-based languages occupy a niche in today&amp;rsquo;s programming language environment. The predominant stack-based language in use by programmers is Forth, and is found mostly on embedded devices. These languages also find use as compile targets for more popular languages: the CIL and JVM are both stack-based. Less popular but highly interesting languages to mention include &lt;a href="http://www.kevinalbrecht.com/code/joy-mirror/joy.html"&gt;Joy&lt;/a&gt; and &lt;a href="http://factorcode.org/"&gt;Factor&lt;/a&gt;, known for their emphasis on higher-order stack-based programming.&lt;/p&gt;

&lt;p&gt;The majority of stack-based languages are not statically typed, and it would be a stretch to call Forth even dynamically typed. As such, developing large projects in Forth or Factor can require great discipline on the part of the programmer to avoid type errors.&lt;/p&gt;

&lt;p&gt;In this talk, I presented the development of type inference for stack-based languages as a linear sequence, divided into two overarching segments:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;An algebraic system known as &lt;em&gt;stack effects&lt;/em&gt;&lt;/li&gt;
 &lt;li&gt;Systems that can be encoded as &lt;em&gt;nested pairs&lt;/em&gt; in standard functional  programming languages&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;The thread of research on stack effects began with Jaanus P√∂ial in the early 1990&amp;rsquo;s, and is a formalization of a commenting style well-known in the Forth community. The nested tuple systems were first examined by Okasaki in 1993 in the context of Haskell, and were later applied to higher-order stack-based languages. At the end, I give some avenues for extending the research on these systems, and list some pitfalls to be avoided in further research.&lt;/p&gt;

&lt;p&gt;Full notes (as PDF documents) &amp;mdash; see the &lt;a href="https://github.com/nuprl/hopl-s2017/tree/master/type-inference-for-stack-languages"&gt;git repository&lt;/a&gt; for more documents:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="/blog/static/stack-languages-talk-notes.pdf"&gt;Talk notes&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="/blog/static/stack-languages-annotated-bib.pdf"&gt;Annotated bibliography&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>PLT Redex: mf-apply</title>
   <link>http://prl.ccs.neu.edu/blog/2017/03/03/plt-redex-mf-apply?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-03-03-plt-redex-mf-apply</guid>
   <pubDate>Fri, 03 Mar 2017 08:54:20 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;The &lt;code&gt;mf-apply&lt;/code&gt; keyword is for checked metafunction application in PLT Redex. In other words, &lt;code&gt;(mf-apply f x)&lt;/code&gt; is just like &lt;code&gt;(f x)&lt;/code&gt;, but errors if &lt;code&gt;f&lt;/code&gt; is  not a previously-defined metafunction.&lt;/p&gt;

&lt;p&gt;Also, consider applying to attend &lt;em&gt;The Racket School of Semantics and Languages&lt;/em&gt; in Salt Lake City this summer: &lt;a href="http://summer-school.racket-lang.org/2017/"&gt;http://summer-school.racket-lang.org/2017/&lt;/a&gt;&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="metafunctions-vs-list-patterns"&gt;Metafunctions vs. List Patterns&lt;/h2&gt;

&lt;p&gt;Have you used PLT Redex? Good! Maybe this has happened to you:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang racket
(require redex)

;; -----------------------------------------------------------------------------
;; 1. You define a language
(define-language STLC
  [V ::= integer boolean C]
  [C ::= (closure Œõ œÅ)]
  [Œõ ::= (Œª (x : œÑ) M)]
  [M ::= (M M) V Œõ x]
  [œÑ ::= Int Bool (œÑ ‚Üí œÑ)]
  [œÅ ::= ((x V) ...)]
  [Œì ::= ((x œÑ) ...)]
  [x ::= variable-not-otherwise-mentioned]
  #:binding-forms (Œª (x : œÑ) M #:refers-to x))


;; -----------------------------------------------------------------------------
;; 2. You define a few metafunctions
(define-metafunction STLC
  closure-&amp;gt;lam : C -&amp;gt; Œõ
  [(closure-&amp;gt;lam (closure Œõ œÅ))
   Œõ])

(define-metafunction STLC
  closure-&amp;gt;env : C -&amp;gt; œÅ
  [(closure-&amp;gt;env (closure Œõ œÅ))
   œÅ])


;; -----------------------------------------------------------------------------
;; 3. You try defining a judgment form . . .
(define-judgment-form STLC
  #:mode (free-variables I O)
  #:contract (free-variables M (x ...))
  [
   --- FVS-Var
   (free-variables x (x))]
  [
   (free-variables M_0 (x_0 ...))
   (free-variables M_1 (x_1 ...))
   --- FVS-App
   (free-variables (M_0 M_1) (x_0 ... x_1 ...))]
  [
   (where (Œª (x_0 œÑ) M) Œõ)
   (free-variables M (x_1 ...))
   (where (x_2 ...) ,(set-remove (term (x_1 ...)) (term x_0)))
   --- FVS-Œõ
   (free-variables Œõ (x_2 ...))]
  [
   --- FVS-Integer
   (free-variables integer_0 ())]
  [
   --- FVS-Boolean
   (free-variables boolean_0 ())]
  [
   (where Œõ (closure-&amp;gt;lam C))
   (free-variables Œõ (x_0 ...))
   (where ((x_1 œÑ_1) ...) (closure-env C))
   (where (x_2 ...) ,(set-subtract (term (x_0 ...)) (term (x_1 ...))))
   --- FVS-Closure
   (free-variables C (x_2 ...))])


;; -----------------------------------------------------------------------------
;; 4. You test the judgment, and it mysteriously fails
(judgment-holds
  (free-variables (closure (Œª (x : Int) x) ())
                  ()))
;; ==&amp;gt; #f
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;WHAT HAPPENED??!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The problem is this line in the &lt;code&gt;FVS-Closure&lt;/code&gt; rule:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;   ....
   (where ((x_1 œÑ_1) ...) (closure-env C))
   ....
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;which checks that the list &lt;code&gt;(closure-env C)&lt;/code&gt; (whose first element is the  symbol &lt;code&gt;closure-env&lt;/code&gt; and second element is the symbol &lt;code&gt;C&lt;/code&gt;) matches the pattern  &lt;code&gt;((x_1 œÑ_1) ...)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Right.&lt;/p&gt;

&lt;p&gt;Of course you meant to apply the metafunction &lt;code&gt;closure-&amp;gt;env&lt;/code&gt; but made a typo. And since the syntax for metafunction application is the same as the syntax  for building a list, Redex doesn&amp;rsquo;t report an error.&lt;/p&gt;

&lt;p&gt;We can fix this code with the new &lt;a href="https://www.cs.utah.edu/plt/snapshots/current/doc/redex/The_Redex_Reference.html#%28form._%28%28lib._redex%2Freduction-semantics..rkt%29._mf-apply%29%29"&gt;&lt;code&gt;mf-apply&lt;/code&gt;&lt;/a&gt; keyword (available on &lt;a href="https://github.com/racket/racket"&gt;GitHub&lt;/a&gt; or in a &lt;a href="https://www.cs.utah.edu/plt/snapshots/"&gt;snapshot build&lt;/a&gt;):&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;   ....
   (where ((x_1 œÑ_1) ...) (mf-apply closure-env C))
   ....
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Running &lt;code&gt;raco make&lt;/code&gt; now gives a compile-time error.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  term: expected a previously defined metafunction
    at: closure-env
    in: (mf-apply closure-env C)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="but-i-still-need-to-type-mf-apply-correctly"&gt;But I still need to type &lt;code&gt;mf-apply&lt;/code&gt; correctly!&lt;/h3&gt;

&lt;p&gt;Leif Andersen says:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;I should point out that this has the issue of you still need to type &lt;code&gt;mf-apply&lt;/code&gt; correctly. ;)&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;That is, if you accidentally write:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;   ....
   (where ((x_1 œÑ_1) ...) (mf-applu closure-env C))
   ....
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;Then the code compiles, thinking you intend to match a list of three elements  against the pattern.&lt;/p&gt;

&lt;p&gt;Never fear, there are at least two solutions.&lt;/p&gt;

&lt;h4 id="solution-1-rename-mf-apply"&gt;Solution 1: rename &lt;code&gt;mf-apply&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;A simple fix is to rename the &lt;code&gt;mf-apply&lt;/code&gt; keyword to something shorter (and harder to mis-type):&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang racket
(require redex
         (rename-in redex
           [mf-apply MF]))
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;h4 id="solution-2-the-mf-apply-lang-extension"&gt;Solution 2: the &lt;code&gt;mf-apply&lt;/code&gt; lang extension&lt;/h4&gt;

&lt;p&gt;A fancier solution is to install the &lt;code&gt;mf-apply&lt;/code&gt; meta-language.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $ raco pkg install mf-apply&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This language updates the &lt;a href="http://docs.racket-lang.org/reference/readtables.html#%28tech._readtable%29"&gt;&lt;em&gt;readtable&lt;/em&gt;&lt;/a&gt;  to interpret S-expressions that begin with &lt;code&gt;#{&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang mf-apply racket
(require redex)

(term #{f x ...})
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;as a metafunction application:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;table class="sourcetable"&gt;
  &lt;tbody&gt;
   &lt;tr&gt;
    &lt;td class="linenos"&gt;
     &lt;div class="linenodiv"&gt;
      &lt;pre&gt;1
2
3
4&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;
    &lt;td class="code"&gt;
     &lt;div class="source"&gt;
      &lt;pre&gt;#lang mf-apply racket
(require redex)

(term (mf-apply f x ...))
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;You the programmer only needs to write the &lt;code&gt;#{....}&lt;/code&gt; syntax.&lt;/p&gt;

&lt;p&gt;Source code is on GitHub:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/bennn/mf-apply"&gt;https://github.com/bennn/mf-apply&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;(It&amp;rsquo;s the simplest lang-extension I know of)&lt;/p&gt;

&lt;h2 id="what-is-plt-redex"&gt;What is PLT Redex?&lt;/h2&gt;

&lt;p&gt;PLT Redex is a library for semantics engineering. One of my favorite Redex features is it implements capture-avoiding substitution  and Œ±-equivalence for any language with a &lt;code&gt;#:binding-forms&lt;/code&gt; specification  (such as STLC, above).&lt;/p&gt;

&lt;p&gt;You can read more:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;in the &amp;ldquo;Amb&amp;rdquo; tutorial: &lt;a href="http://docs.racket-lang.org/redex/tutorial.html"&gt;http://docs.racket-lang.org/redex/tutorial.html&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;in the &amp;ldquo;Long Tutorial&amp;rdquo;: &lt;a href="http://docs.racket-lang.org/redex/redex2015.html"&gt;http://docs.racket-lang.org/redex/redex2015.html&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;in the Redex reference manual: &lt;a href="http://docs.racket-lang.org/redex/The_Redex_Reference.html"&gt;http://docs.racket-lang.org/redex/The_Redex_Reference.html&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;on the PLT Redex website: &lt;a href="https://redex.racket-lang.org/"&gt;https://redex.racket-lang.org/&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;on GitHub: &lt;a href="https://github.com/racket/redex"&gt;https://github.com/racket/redex&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;And if you act now, you can become a &lt;em&gt;Redexan&lt;/em&gt; between July 10 and July 14  at the summer school in Salt Lake City, Utah:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="http://summer-school.racket-lang.org/2017/"&gt;http://summer-school.racket-lang.org/2017/&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>PLISS: Oregon without the greek</title>
   <link>http://prl.ccs.neu.edu/blog/2017/02/28/pliss-oregon-without-the-greek?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-02-28-pliss-oregon-without-the-greek</guid>
   <pubDate>Tue, 28 Feb 2017 23:01:00 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;What does every student interested in programming languages need to learn about the practical side of the field? That is the question that the first international summer school on programming language implementation (or &lt;a href="https://pliss2017.github.io"&gt;PLISS&lt;/a&gt; for short) has set out to answer.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;p&gt;&lt;img src="/img/pliss_summer_school_2017_logo.png" alt="PLISS logo" /&gt;&lt;/p&gt;

&lt;p&gt;The school will feature &lt;a href="https://pliss2017.github.io/speakers.html"&gt;twelve speakers&lt;/a&gt; versed in programming language practicae ranging from abstract interpretation to garbage collection and from compiler implementation to language design. The lectures will feature hands on exercises as well as lessons learned from large scale industrial efforts.&lt;/p&gt;

&lt;p&gt;Lectures cover current research and future trends in programming language design and implementation, including:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Writing Just-in-time Compilers with LLVM with Jan Vitek&lt;/li&gt;
 &lt;li&gt;Performance Evaluation and Benchmarking with Laurie Tratt&lt;/li&gt;
 &lt;li&gt;Designing a Commercial Actor Language with Sophia Drossopoulou and Heather Miller&lt;/li&gt;
 &lt;li&gt;High-Performance Fully Concurrent Garbage Collection with Richard Jones&lt;/li&gt;
 &lt;li&gt;Compiling Dynamic Languages with David Edelsohn&lt;/li&gt;
 &lt;li&gt;Language-support for Distributed Datastores with Suresh Jagannathan&lt;/li&gt;
 &lt;li&gt;Testing Programming Language Implementations with Alastair Donaldson&lt;/li&gt;
 &lt;li&gt;Abstract Interpretation and Static Analysis with lectures by Francesco Logozzo and Matt Might&lt;/li&gt;
 &lt;li&gt;The evolution of Scala with Martin Odersky&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;A summer school is also an opportunity to get know the speakers and get ideas for research problems. Students will have the opportunity to socialize with a peer group of other students in PL as well as professors and industrial researchers.&lt;/p&gt;

&lt;p&gt;Thanks to generous funding from NSF, ONR and SIGPLAN, costs will be kept low and some fellowships are available to cover travel costs.&lt;/p&gt;

&lt;p&gt;More information at:&lt;/p&gt;

&lt;p&gt;&lt;a href="https://pliss2017.github.io"&gt;https://pliss2017.github.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;(Oregon is a reference to the &lt;a href="https://www.cs.uoregon.edu/research/summerschool/summer17/"&gt;OPLSS&lt;/a&gt;, in which you may also be interested.)&lt;/p&gt;</description></item>
  <item>
   <title>Linear Types for Low-level Languages</title>
   <link>http://prl.ccs.neu.edu/blog/2017/02/28/linear-types-for-low-level-languages?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-02-28-linear-types-for-low-level-languages</guid>
   <pubDate>Tue, 28 Feb 2017 09:51:55 UT</pubDate>
   <author>PRL</author>
   <description>&lt;!-- more--&gt;

&lt;p&gt;In this talk, we covered early papers (primarily, by Girard, Lafont, and Abramsky) on linear logic and its reflections into computation. The goal was to understand why linearity is often turned to as a principled way to control resource usage, as shows up in a language like Rust. From the very beginning, researchers realized the implications for &amp;ldquo;low-level&amp;rdquo; languages - that linear resources would eliminate the need for garbage collection, allow in-place mutation, and enable safe parallel computation. However, pure implementations of linearity incur lots of copying, doing away with any efficiency gained, and we covered a survey of papers that attempted to reconcile this contradiction by weakening linearity in controlled ways.&lt;/p&gt;

&lt;p&gt;Notes:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;a href="https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017-02-14.md"&gt;https://github.com/nuprl/hopl-s2017/blob/master/lecture_notes/2017&amp;ndash;02&amp;ndash;14.md&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Just after the talk, over lunch, we had a lab discussion about the phrase &amp;ldquo;low level&amp;rdquo;. Here are some thoughts:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;the phrase is relative, both over time and depending on the programming  task at hand&lt;/li&gt;
 &lt;li&gt;a &amp;ldquo;low level&amp;rdquo; task is &amp;ldquo;one that you shouldn&amp;rsquo;t need to worry about&amp;rdquo; while  solving your current task&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;And here are some example &amp;ldquo;low-level&amp;rdquo; tasks:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;Time and space management is &amp;ldquo;low level&amp;rdquo; when designing a new algorithm  (the first question is correctness)&lt;/li&gt;
 &lt;li&gt;Calling conventions and endian-ness (facets of the damn machine running  the programs) are almost always low-level&lt;/li&gt;
 &lt;li&gt;Whether a given value is serializable is usually low-level&lt;/li&gt;
 &lt;li&gt;Possible side effects, thrown exceptions, and optional arguments can all  be considered &amp;ldquo;low level&amp;rdquo; aspects of library functions. This is low-level  in the sense that &amp;ldquo;I&amp;rsquo;d rather use a simpler type to think about this library&amp;rdquo;&lt;/li&gt;
 &lt;li&gt;Managing type annotations is a low-level detail in ML programs&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Bullets are good for your Coq proofs</title>
   <link>http://prl.ccs.neu.edu/blog/2017/02/21/bullets-are-good-for-your-coq-proofs?utm_source=all&amp;utm_medium=RSS</link>
   <guid isPermaLink="false">urn:http-prl-ccs-neu-edu:-blog-2017-02-21-bullets-are-good-for-your-coq-proofs</guid>
   <pubDate>Tue, 21 Feb 2017 19:04:28 UT</pubDate>
   <author>PRL</author>
   <description>
&lt;p&gt;I believe that bullets are one of the most impactful features of recent versions of Coq, among those that non-super-expert users can enjoy. They had a big impact on the maintainability of my proofs. Unfortunately, they are not very well-known, due to the fact that some introductory documents have not been updated to use them.&lt;/p&gt;

&lt;p&gt;Bullets are a very general construction and there are several possible ways to use them; I have iterated through different styles. In this post I will give the general rules, and explain my current usage style.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h2 id="why-bullets"&gt;Why bullets&lt;/h2&gt;

&lt;p&gt;While you are doing a proof, Coq shows a list of subgoals that have to be proved before the whole proof is complete. Most proof steps will operate on the current active subgoal, changing the hypotheses or the goal to prove, but some proof steps will split it into several subgoals (growing the total list of goals), or may terminate the proof of the current subgoal and show you the next active subgoal.&lt;/p&gt;

&lt;p&gt;Before bullets, a typical proof script would contain the proofs of each subgoal, one after another.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;induction foo. (* this creates many subgoal *)

proof of first subgoal.

proof of second subgoal.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are many ways to structure this to make the structure more apparent: people would typically have a comment on each subgoal, or make disciplined use of indentation and blank lines. But, in my experience, a major problem with this style was maintainability in the face of changes to the definitions or parts of automation. It could be very hard of what was happening when a proof suddenly broke after a change before in the file:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;If a proof step now proves &lt;em&gt;less&lt;/em&gt; things, then what used to be the  end of a subgoal may not be anymore. Coq would then start reading  the proof of the next subgoal and try to apply it to the unfinished  previous goals, generating very confusing errors (you believe you  are in the second subgoal, but the context talks about a leaf case  of the first goal).&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If a proof step now proves &lt;em&gt;more&lt;/em&gt; things, it is also very bad! The  next proof steps, meant for the first subgoal (for example), would  then apply to the beginning of the second subgoal, and you get very  confusing errors again.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;What we need for robustness is a way to indicate our &lt;em&gt;intent&lt;/em&gt; to Coq, when we think that a subgoal is finished and that a new subgoal starts, so that Coq can fail loudly at the moment where it notices that this intent does not match reality, instead of at an arbitrary later time.&lt;/p&gt;

&lt;p&gt;(The &lt;code&gt;S*Case&lt;/code&gt; tactics used in (older versions of) Software Foundations can solve this problem if used in a carefully, systematic way, and additionally provides naming. Alexandre Pilkiewicz implemented an even more powerful &lt;a href="https://github.com/pilki/cases"&gt;cases&lt;/a&gt; plugin. Bullets are available in standard Coq since 8.4 (released in 2012), and can be used with no effort.)&lt;/p&gt;

&lt;p&gt;There is not much discussion of bullets around; see the &lt;a href="https://coq.inria.fr/distrib/8.6/refman/Reference-Manual009.html#sec326"&gt;documentation&lt;/a&gt; in the Coq manual. I learned a lot from Arthur Azevedo de Amorim&amp;rsquo;s &lt;a href="https://github.com/arthuraa/poleiro/blob/master/theories/Bullets.v"&gt;Bullets.v&lt;/a&gt; file.&lt;/p&gt;

&lt;p&gt;Finally, some people don&amp;rsquo;t use bullets, because they systematically use so much automation that they never see subgoals &amp;mdash; each lemma has a one-line proof. This is also a valid style. (I have been going to Adam Chlipala&amp;rsquo;s &lt;a href="https://frap.csail.mit.edu/main"&gt;Formal Reasoning about Programs&lt;/a&gt; 2017 class, where Adam ignores bullets because that is his usual style.) Because I am not crushy enough to do this from the start, my proofs tend to start with cases and subgoals, and then I refine them to add more automation for robustness. I found bullets very useful for the first step, and during the refinement process.&lt;/p&gt;

&lt;h2 id="bullets"&gt;Bullets&lt;/h2&gt;

&lt;p&gt;Bullets are actually a combination of two features, braces &lt;code&gt;{ ... }&lt;/code&gt; and actual list bullets &amp;mdash; &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, or homogeneous repetitions of those, for example &lt;code&gt;--&lt;/code&gt; or &lt;code&gt;***&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id="braces"&gt;Braces&lt;/h3&gt;

&lt;p&gt;The opening brace &lt;code&gt;{&lt;/code&gt; focuses the proof on the current subgoal. If you finish the proof of the subgoal, the following subgoal will not become accessible automatically; you have to use the closing brace &lt;code&gt;}&lt;/code&gt; first. (If you finish the goal earlier than you think, you get an error.) Conversely, &lt;code&gt;}&lt;/code&gt; fails if the subgoal is not complete. (If you fail to finish, you get an error.)&lt;/p&gt;

&lt;p&gt;The previous example can thus be written as follows, and will be more robust:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;induction foo. (* this creates many subgoal *)
{
  proof of first subgoal.
}
{
  proof of second subgoal.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you also want to make sure that an error occurs if the number of subgoals changes (for example if new constructors are added to the inductive type of &lt;code&gt;foo&lt;/code&gt;), you can use an outer layer of braces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ induction foo. (* this creates many subgoal *)
  {
    proof of first subgoal.
  }
  {
    proof of second subgoal.
  }
} (* would fail if a new subgoal appeared *)&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id="list-bullets"&gt;List bullets&lt;/h3&gt;

&lt;p&gt;A bullet, for example &lt;code&gt;--&lt;/code&gt;, also focuses on the next subgoal. The difference is that when the subgoal is finished, you do not have a closing construction, you must use the same bullet to move to the next subgoal. (Again, this fails if the first proof step changes to prove too much or too little.) With bullets you would write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;induction foo. (* this creates many subgoal *)
+ proof of first subgoal.
+ proof of second subgoal.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bullets can be nested, but you must use different bullets for the different nesting levels. For example, if this proof is only one subgoal of a larger proof, you can use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- induction foo. (* this creates many subgoal *)
  + proof of first subgoal.
  + proof of second subgoal.
- (* would fail if a new subgoal appeared *)
  rest of the proof&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The natural ordering of bullets, I think, is by increasing number of lines: &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt; then &lt;code&gt;*&lt;/code&gt; (and then multi-character bullets, I guess). You can also mix bullets with braces: the opening brace resets the bullet scope, any bullet can be used again with the subgoal.&lt;/p&gt;

&lt;p&gt;This gives a large space of freedom in how you want to use these features. You can use only braces, only bullets, braces and only one level of bullets, etc. My own style evolved with experience using the feature, and I will present the current status below.&lt;/p&gt;

&lt;h2 id="my-current-bullet-style"&gt;My current bullet style&lt;/h2&gt;

&lt;p&gt;When deciding how to use bullets, one distinguishes the commands that preserve the number of subgoals and those that may create new subgoals. I use some additional distinctions.&lt;/p&gt;

&lt;p&gt;Some tactics, for example &lt;code&gt;assert&lt;/code&gt;, create a number of subgoals that is &lt;em&gt;statically&lt;/em&gt; known, always the same for the tactic. I then use braces around each sub-proof, except the last one, which I think of as the &amp;ldquo;rest&amp;rdquo; of the current proof.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;assert foo as H.
{ proof of foo. }
rest of the proof using H:foo.&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(If the proof of &lt;code&gt;foo&lt;/code&gt; takes several lines, I two-indent them, with the braces alone on their lines.)&lt;/p&gt;

&lt;p&gt;Most tactics create a &lt;em&gt;dynamic&lt;/em&gt; number of subgoals, that depends on the specifics of the objects being operated on; this is the case of &lt;code&gt;case&lt;/code&gt;, &lt;code&gt;destruct&lt;/code&gt;, &lt;code&gt;induction&lt;/code&gt; for example. In this case, I open a brace before the tactic, and use a bullet for each subgoal.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ induction foo; simpl; auto.
- proof of first remaining subgoal.
- proof of second remaining subgoal.
  rest of the proof of the second subgoal.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice that the subgoal-creating step is vertically aligned with the proof steps: I use both braces and bullets, but take only one indentation level each time.)&lt;/p&gt;

&lt;p&gt;As an exception, I may omit the braces if we are at the toplevel of the proof (&lt;code&gt;Proof .. Qed&lt;/code&gt; serve as braces).&lt;/p&gt;

&lt;p&gt;Note that omitting the braces here and using different bullets when you nest is also just fine. In my experience it gives proofs that are a bit more pleasant to read but also a bit more cumbersome to edit and move around.&lt;/p&gt;

&lt;p&gt;Finally, a not-uncommon mode of use of &amp;ldquo;dynamic&amp;rdquo; tactics in the sense above is to expect all the cases, except one, to be discharged by direct automation (for example they are all absurd except one). When it is my intent that all cases but one be discharged (and not a coincidence), I express it by not using braces (this command preserves the number of subgoals), but marking the remaining subgoal with a new bullet &lt;em&gt;without&lt;/em&gt; increasing the indentation level.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ induction foo.
- first subgoal.
- second subgoal.
  case blah; discharge all sub-subgoals but one.
+ remaining sub-subgoal of the second subgoal.
  finish the sub-subgoal.
- third subgoal.
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This is the only time where I use several bullet levels.)&lt;/p&gt;

&lt;p&gt;If you are the kind of programmer that is passionate about indentation style, I should now have tricked you to use bullets to propose a different variant. Otherwise, please consider using bullets anyway, for example by following the style above, it will make your life easier in the face of changing developments.&lt;/p&gt;</description></item></channel></rss>